stringLiteral

Simplified BNF to CQL script. The focus here is split in SPACES, WHERE, ITEM-NAME and LITERAL tokens.


Notes:

1-) u(TOKEN) means an uncasesensitive token
2-) ^TOKEN means a not token
3-) ? means any character
4-) []n eg: [...]¹,[...]² ..... - mutual option or mutal required. Each part cannot appears alone.


OFICIAL BNF: https://cassandra.apache.org/doc/cql/CQL.html
 
TODO 0-) Corrigir CQL	

TODO 1-) Corrigir hexa

TODO 2-) Corrigir o conditions pois ele aceita alias

TODO 3-) Corrigir onde usa dot comma pra usar a função isDotcomma

TODO 4-) Numa versão 3 usar o BNF oficial

<CQL>::=[<SPACES>] <COMMAND> [ <SPACES>] [<DOT COMMA> [<SPACES>]]

<EMPTY>::=""
Notes: 
1-) only content between ""

<SPACES>::=<SPACE> [<SPACES>]

<SPACE>::=" "
Notes: 
1-) only content between ""

<COMMAND>::=<CREATE TABLE COMMAND>  | ((<INSERT COMMAND> |<OTHER COMMAND>) [ <SPACES> <CONDITION>  ])

<INSERT COMMAND>::=<INSERT> <SPACES> [<INTO> <SPACES>] <SELECTOR ITEM>  [<SPACES>]  <START_PARAMETERS> [<SPACES>]  <SELECTOR BLOCK>  [<SPACES>] <END_PARAMETERS>  [<SPACES>] <VALUES> [<SPACES>]  <START_PARAMETERS> [<SPACES>]  [<SELECTOR BLOCK>]  [<SPACES>] <END_PARAMETERS>

<CREATE TABLE COMMAND>::=<START CREATE TABLE>  <END CREATE TABLE>
Notes: 
Create table not accept inject

<START CREATE TABLE>::=<CREATE> <SPACES> <TABLE>

<CREATE>::=u(CREATE)

<TABLE>::=u(TABLE)

<END CREATE TABLE>::=^<DOT COMMA> ? [<END CREATE TABLE>]

<OTHER COMMAND>::=^<WHERE> <RESERVED WORDS> [<SPACES>] (<SELECTOR BLOCK> | (  [<SYMBOL>] [<SPACES>]  [<LITERAL>] )[<SPACES>] ) [[<SPACES>]<OTHER COMMAND>]


<INTO>::=u(INTO)

<INSERT>::=u(INSERT)

<VALUES>::=u(VALUES)

<RESERVED WORDS>::=<RESERVED WORD> [<SPACES> <RESERVED WORDS>]

<RESERVED WORD>::=ADD	|	ALL	|	ALLOW	|	ALTER	|	AND	|	ANY	|	APPLY	|	ASC	|	ASCII	|	AUTHORIZE	|	BATCH	|	BEGIN	|	BIGINT	|	BLOB	|	BOOLEAN	|	BY	|	
CLUSTERING	|	COLUMNFAMILY	|	COMPACT	|	COUNT	|	COUNTER	|	CONSISTENCY	|	CREATE	|	DECIMAL	|	DELETE	|	DESC	|	DOUBLE	|	DROP	|	EACH_QUORUM	|	FILTERING	|
FLOAT	|	FROM	|	GRANT	|	IN	|	INDEX	|	INET	|	INSERT	|	INT	|	INTO	|	KEY	|	KEYSPACE	|	KEYSPACES	|	LEVEL	|	LIMIT	|	LIST	|	LOCAL_ONE	|
LOCAL_QUORUM	|	MAP	|	MODIFY	|	OF	|	ON	|	ONE	|	ORDER	|	PASSWORD	|	PERMISSION	|	PERMISSIONS	|	PRIMARY	|	QUORUM	|	RENAME	|
REVOKE	|	RECURSIVE	|	SUPERUSER	|	SCHEMA	|	SELECT	|	SET	|	STORAGE	|	SUPERUSER	|	TABLE	|	TEXT	|	TIMESTAMP	|	TIMEUUID	|	TO	|	TOKEN	|	THREE	|	
TRUNCATE	|	TTL	|	TWO	|	TYPE	|	UNLOGGED	|	UPDATE	|	USE	|	USER	|	USERS	|	USING	|	UUID	|	VALUES	|	VARCHAR	|	VARINT	|	WITH	|	WRITETIME
Notes:
1-) case insensitive

<FUNCTION>::=<ITEM NAME>[<SPACES>]<START_PARAMETERS>[<SPACES>][<CONDITION-ITEM>][<SPACES>]<END_PARAMETERS>

<START_PARAMETERS>::=(

<END_PARAMETERS>::=)

<START ARRAY>::=[
<END ARRAY>::=]

<START MAP>::={
<END MAP>::=}

<CONDITION-ITEM>::=<SELECTOR ITEM>[<SPACES>]<SYMBOL>[<SPACES>]<SELECTOR ITEM>


<SELECTOR BLOCK>::=^<WHERE> <SELECTOR ITEM>  [[<SPACES>] <COMMA> [<SPACES>] <SELECTOR BLOCK>]

<SELECTOR ITEM>::=^<RESERVED WORD>  (<FUNCTION> | <LITERAL> |<ITEM NAME> [<ACESSOR> <FIELD NAME>] |  <ARRAY> | <MAP>)[<SPACES><ALIAS>]

<ALIAS>::=[<AS> <SPACES>] <FIELD NAME>

<FIELD NAME>::=^<RESERVED WORD> (<ITEM NAME CASE SENSITIVE> | <ITEM NAME CASE INSENSITIVE>)

<AS>::=AS

<ARRAY>::=<START ARRAY>[<SPACES>][<SELECTOR BLOCK>][<SPACES>]<END ARRAY>

<MAP>::=<START MAP>[<SPACES>][<PROPERTIES>][<SPACES>]<END MAP>

<PROPERTIES>::=<PROPERTY> [[<SPACES>]<COMMA>[<SPACES>] <PROPERTIES>]

<PROPERTY>::=<KEY>[<SPACES>]<DOUBLE DOT>[<SPACES>](<LITERAL>|

<DOUBLE DOT>::=:

<KEY>::=<CHARS>|<LITERAL>



<ACESSOR>::=.

<ITEM NAME>::=<ITEM NAME CASE SENSITIVE> | <ITEM NAME CASE INSENSITIVE> | <ASTERISK>

<ITEM NAME CASE SENSITIVE>::="<CHARS>" 

<ITEM NAME CASE INSENSITIVE>::=^<NUMBER> <CHARS>   
Notes:
1-) If autowrap, output is the same <ITEM NAME CASE SENSITIVE> (Eg: testValue = > "testValue")
2-) If not autowrap, output is lowercase format (Eg: testValue = > testvalue)

<ASTERISK>::=*

<INJECT>::=?

<CHARS>::=^<EMPTY>[<CHARS>](a-Z0-9_)

<LITERAL>::=(<NUMBER> | <STRING> | <INJECT> | <HEXA>)^<CHARS>

<HEXA>::=(a-f)|(A-F)|<DIGIT>|-[<HEXA>]
Notes: 
1-) The position of the hyphen will not be validated	

<NUMBER>::=<DIGIT>[<NUMBER>]

<DIGIT>::=(0-9)

<STRING>::=(<SINGLE QUOTED>[<INPUT CHARACTER EXCEPT SINGLE>]<SINGLE QUOTED>) | (<DOUBLE QUOTED>[<INPUT CHARACTER EXCEPT DOUBLE>]<DOUBLE QUOTED>) 

<SINGLE QUOTED>::='<INPUT CHARACTER EXCEPT SINGLE>'

<DOUBLE QUOTED>::="<INPUT CHARACTER EXCEPT DOUBLE>"

<INPUT CHARACTER EXCEPT SINGLE>::=(^<SINGLE QUOTED><CHARS>)[<INPUT CHARACTER EXCEPT SINGLE>]

<INPUT CHARACTER EXCEPT DOUBLE>::=(^<DOUBLE QUOTED><CHARS>)[<INPUT CHARACTER EXCEPT DOUBLE>] 

Notes:
1-) Any character except ' unless is part of a double quoted ''  

<SYMBOL>::== | + |  - |  / |  <ASTERISK> |  ( | ) | { | } | , [ | ]

<DOT COMMA>::=;

<COMMA>::=,

<WHERE>::=u(WHERE)

<CONDITION>::=<WHERE>  <CONDITIONS> 

<CONDITIONS>::=<SPACES><CONDITION-ITEM>[<SPACES> <JOIN CONDITION> <CONDITIONS>]

<JOIN CONDITION>::=<AND> | <OR>

<AND>::=u(AND)

<OR>::=u(OR)


u(x)::=case insensitive

Examples:

1-) SELECT * FROM MyColumnFamily;

2-) UPDATE MyColumnFamily SET 'SomeColumn' = 'SomeValue' WHERE KEY = B70DE1D0-9908-4AE3-BE34-5573E5B09F14;
