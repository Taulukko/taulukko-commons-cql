stringLiteral

Simplified BNF to CQL script. The focus here is split in SPACES, WHERE, ITEM-NAME and LITERAL tokens.


Notes:

1-) u(TOKEN) means an uncasesensitive token
2-) ^TOKEN means a not token and not consume the next token, example ^7<number> means "8" is accept but "a8" not because "8" is not 7 AND is a number, a8 is not 7 but is NOT is a number.
3-) ? means any character
4-) []n eg: [...]¹,[...]² ..... - mutual option or mutal required. Each part cannot appears alone.

OFICIAL BNF: https://cassandra.apache.org/doc/cql/CQL.html

TODO 0 -)  Testar  FillParametersTest,ReplaceTest, arrumar repo, a copia tem as alteracoes corretas mas talvez seja necessario rebaixar

TODO 2-) Testar no ceu

TODO 3- ) Converter a string timezone para constante

TODO 4-) Numa versão 3 usar o BNF oficial, vale a pena ?

<CQL>::=[<SPACES>] <COMMAND> [ <SPACES>] [<USING>] [<DOT COMMA> [<SPACES>]]

<EMPTY>::=""
Notes: 
1-) only content between "" 

<SPACES>::=<SPACE> [<SPACES>]

<SPACE>::=" "
Notes: 
1-) only content between ""

<USING>::=<START USING> <SPACES> <USING OPTIONS>

<START USING>::="USING"

<USING OPTIONS>::=<TTL>

<TTL>::=<START TTL> <SPACES> (<NUMBER>  | <INJECT> )

<START TTL>::=u("TTL")


<COMMAND>::=<CREATE COMMAND>  | <INSERT COMMAND> | <CONDITIONAL COMMAND>

<CONDITIONAL COMMAND>::=(<DELETE COMMAND> | <UPDATE COMMAND> | <OTHER COMMAND>) [ <SPACES> <CONDITION>  ]

<CREATE COMMAND>::=<CREATE TABLE COMMAND> | <CREATE INDEX COMMAND>

<CREATE INDEX COMMAND>::=<START CREATE INDEX COMMAND> <END CREATE INDEX COMMAND>

<START CREATE INDEX COMMAND>::=<CREATE> <SPACES> <INDEX>

<INDEX>::=u(INDEX)

<END CREATE INDEX COMMAND>::=^<DOT COMMA> <ANY> [<END CREATE INDEX COMMAND>]

<INSERT COMMAND>::=<INSERT> <SPACES> [<INTO> <SPACES>] <TABLE NAME DECLARATION>  [<SPACES>]  <START_PARAMETERS> [<SPACES>]  <FIELD LIST>  [<SPACES>] <END_PARAMETERS>  [<SPACES>] <VALUES> [<SPACES>]  <START_PARAMETERS> [<SPACES>]  [<SELECTOR BLOCK>]  [<SPACES>] <END_PARAMETERS>

<CREATE TABLE COMMAND>::=<START CREATE TABLE>  <END CREATE TABLE>
Notes: 
Create table not accept inject

<START CREATE TABLE>::=<CREATE> <SPACES> <TABLE>

<CREATE>::=u(CREATE)

<TABLE>::=u(TABLE)

<END CREATE TABLE>::=^<DOT COMMA> <ANY> [<END CREATE TABLE>]

<OTHER COMMAND>::=^<WHERE> <RESERVED WORDS> [<SPACES>] (<SELECTOR BLOCK> | ( [<SYMBOL>] [<SPACES>] [<LITERAL>] )[<SPACES>] ) [[<SPACES>]<OTHER COMMAND>]

<DELETE COMMAND>::=<START DELETE COMMAND> [<SPACES> <END COMMON COMMAND>]

<UPDATE COMMAND>::=<START UPDATE COMMAND> <SPACES> <END COMMON COMMAND>

<START DELETE COMMAND>::=<DELETE> <SPACES> [<FROM> <SPACES>] <TABLE NAME>

<START UPDATE COMMAND>::=<UPDATE> <SPACES> <TABLE NAME> <SPACES> <SET>

<END COMMON COMMAND>::=(<SELECTOR BLOCK> | <SYMBOL> | <LITERAL>  ) [[<SPACES>]<END COMMON COMMAND>]]

<FROM>::=u(FROM)

<SET>::=u(SET)

<DELETE>::=u(DELETE)

<UPDATE>::=u(UPDATE)

<INTO>::=u(INTO)

<INSERT>::=u(INSERT)

<VALUES>::=u(VALUES)

<RESERVED WORDS>::=<RESERVED WORD> [<SPACES> <RESERVED WORDS>]

<RESERVED WORD>::=ADD	|	ALL	|	ALLOW	|	ALTER	|	AND	|	ANY	|	APPLY	|	ASC	|	ASCII	|	AUTHORIZE	|	BATCH	|	BEGIN	|	BIGINT	|	BLOB	|	BOOLEAN	|	BY	|	
CLUSTERING	|	COLUMNFAMILY	|	COMPACT	|	COUNT	|	COUNTER	|	CONSISTENCY	|	CREATE	|	DECIMAL	|	DELETE	|	DESC	|	DOUBLE	|	DROP	|	EACH_QUORUM	|	FILTERING	|
FLOAT	|	FROM	|	GRANT	|	IN	|	INDEX	|	INET	|	INSERT	|	INT	|	INTO	|	KEY	|	KEYSPACE	|	KEYSPACES	|	LEVEL	|	LIMIT	|	LIST	|	LOCAL_ONE	|
LOCAL_QUORUM	|	MAP	|	MODIFY	|	OF	|	ON	|	ONE	|	ORDER	|	PASSWORD	|	PERMISSION	|	PERMISSIONS	|	PRIMARY	|	QUORUM	|	RENAME	|
REVOKE	|	RECURSIVE	|	SUPERUSER	|	SCHEMA	|	SELECT	|	SET	|	STORAGE	|	SUPERUSER	|	TABLE	|	TEXT	|	TIMESTAMP	|	TIMEUUID	|	TO	|	TOKEN	|	THREE	|	
TRUNCATE	|	TTL	|	TWO	|	TYPE	|	UNLOGGED	|	UPDATE	|	USE	|	USER	|	USERS	|	USING	|	UUID	|	VALUES	|	VARCHAR	|	VARINT	|	WITH	|	WRITETIME
Notes:
1-) case insensitive

<FUNCTION>::=<ITEM NAME>[<SPACES>]<START_PARAMETERS>[<SPACES>][<SELECTOR BLOCK>][<SPACES>]<END_PARAMETERS>

<START_PARAMETERS>::=(

<END_PARAMETERS>::=)

<START BRACKET>::=[

<END ARRAY>::=]

<START MAP>::={

<END MAP>::=}



<CONDITION-ITEM>::=<SELECTOR ITEM STRICT>[<SPACES>]<SYMBOL>[<SPACES>]<SELECTOR ITEM STRICT>

<SELECTOR BLOCK>::=<FIELD VALUE>  [[<SPACES>] <COMMA> [<SPACES>] <SELECTOR BLOCK>]

<FIELD LIST>::=<FIELD NAME>  [[<SPACES>] <COMMA> [<SPACES>] <FIELD LIST>]

<SELECTOR ITEM>::=<SELECTOR ITEM STRICT> [<SPACES><ALIAS>]

<TABLE NAME>::=<ENTITY NAME>

<SELECTOR ITEM STRICT>::=^<RESERVED WORD> <FIELD VALUE>

<ALIAS>::=[<AS> <SPACES>] <ENTITY NAME>

<FIELD NAME>::=[<TABLE NAME>[<SPACES>]<ACESSOR>[<SPACES>]] (<ENTITY NAME>|<ASTERISK>)

<TABLE NAME>::=<ENTITY NAME>

<TABLE NAME DECLARATION>::=<TABLE NAME> [<SPACES>] <ALIAS>]


<FIELD VALUE>::=<FUNCTION> | <ARRAY> | <MAP> |  <FIELD NAME> | <LITERAL> 
Obs: abc.def is a field name, but abc is a literal. So, the order here is very important!

<FIELD NAME DECLARATION>::=<FIELD VALUE> [<SPACES>] <ALIAS>]

<ENTITY NAME>::=^<RESERVED WORD> (<ITEM NAME CASE SENSITIVE> | <ITEM NAME CASE INSENSITIVE>) 

<AS>::=AS

<ARRAY>::=<ARRAY BRACKET> | <ARRAY BRACE>

<ARRAY BRACKET>::=<START ARRAY>[<SPACES>][<SELECTOR BLOCK>][<SPACES>]<END ARRAY>

<ARRAY BRACE>::=<START BRACE>[<SPACES>][<SELECTOR BLOCK>][<SPACES>]<END BRACE>

<START BRACE>::={

<END BRACE>::=}

<MAP>::=<START BRACE>[<SPACES>][<PROPERTIES>][<SPACES>]<END BRACE>

<PROPERTIES>::=<PROPERTY> [[<SPACES>]<COMMA>[<SPACES>] <PROPERTIES>]

<PROPERTY>::=<KEY>[<SPACES>]<DOUBLE DOT>[<SPACES>](<LITERAL>|

<DOUBLE DOT>::=:

<KEY>::=<CHARS>|<LITERAL>



<ACESSOR>::=.

<ITEM NAME>::=<ITEM NAME CASE SENSITIVE> | <ITEM NAME CASE INSENSITIVE> | <ASTERISK>

<ITEM NAME CASE SENSITIVE>::=<DOUBLE QUOTED><CHARS><DOUBLE QUOTED>

<ITEM NAME CASE INSENSITIVE>::=^<NUMBER> <CHARS>   
Notes:
1-) If autowrap, output is the same <ITEM NAME CASE SENSITIVE> (Eg: testValue = > "testValue")
2-) If not autowrap, output is lowercase format (Eg: testValue = > testvalue)

<ASTERISK>::=*

<INJECT>::=?

<CHARS>::=^<EMPTY>[<CHARS>](a-Z0-9_)

<LITERAL>::=(<NUMBER> | <STRING> | <INJECT> | <HEXA>)^<CHARS>


<HEXA>::=[<SIGN>] [<START HEX>] <ABSOLUTE HEX>

<START HEX>::=u(0X)

<ABSOLUTE HEX>::=(<HEXA CHAR>|<DIGIT>) [<ABSOLUTE HEX>]

<HEXA CHAR> :: = u(a-f)

<NUMBER>::=<DIGIT>[<NUMBER>]

<DIGIT>::=(0-9)

<STRING>::=(<SINGLE QUOTED>[<INPUT CHARACTER EXCEPT SINGLE>]<SINGLE QUOTED>) | (<DOUBLE QUOTED>[<INPUT CHARACTER EXCEPT DOUBLE>]<DOUBLE QUOTED>) 

<SINGLE QUOTED>::='

<DOUBLE QUOTED>::="

<INPUT CHARACTER EXCEPT SINGLE>::=(<SINGLE QUOTED><SINGLE QUOTED> | (^<SINGLE QUOTED><ANY>))[<INPUT CHARACTER EXCEPT SINGLE>]

<INPUT CHARACTER EXCEPT DOUBLE>::=(<DOUBLE QUOTED><DOUBLE QUOTED> | (^<DOUBLE QUOTED><ANY>))[<INPUT CHARACTER EXCEPT DOUBLE>]

<ANY>::=?

<SYMBOL>::=<SIGN>|<ASTERISK>|=| / |  ( | ) | { | } | , [ | ]

<SIGN>::=+|-

<DOT COMMA>::=;

<COMMA>::=,

<WHERE>::=u(WHERE)

<CONDITION>::=<WHERE>  <CONDITIONS> 

<CONDITIONS>::=<SPACES><CONDITION-ITEM>[<SPACES> <JOIN CONDITION> <CONDITIONS>]

<JOIN CONDITION>::=<AND> | <OR>

<AND>::=u(AND)

<OR>::=u(OR)


u(x)::=case insensitive

Examples:

1-) SELECT * FROM MyColumnFamily;

2-) UPDATE MyColumnFamily SET 'SomeColumn' = 'SomeValue' WHERE KEY = B70DE1D0-9908-4AE3-BE34-5573E5B09F14;
